# Design Patterns in Ruby

Hello and welcome! 👋 This repository serves as a personal reference for implementing **design patterns in Ruby**, inspired by the classic *Gang of Four (GOF)* design patterns.

The code here is modeled after implementations from *Design Patterns in Ruby* by Russ Olsen.

---

## 📌 What Are Design Patterns?
Design patterns are **reusable solutions** to common software design problems in **object-oriented programming (OOP)**. These patterns are **well-tested** and provide **elegant, maintainable solutions** for structuring code effectively.

---

## 🚀 What Should You Know Before Learning?
**Nothing!** Well... maybe just the basics of programming. Here’s a quick checklist to help you get started:

- **Data Types**: Integers, Floats, Strings, Char, Boolean
- **Variables**: Assigning and using variables
- **Operators**: `+`, `-`, `*`, `/`, `==`, `<`, `<=`, `>`, `>=`, `&&`, `||`, `!`
- **Arrays**: Understanding `push` and `pop` (stack/queue concepts)
- **Hashes**: Key-value pair dictionaries
- **Conditional Statements**: `if`, `elsif`, `else`
- **Loops**: `while`, `foreach`
- **Importing Code**: Using `require` or `include` to pull in external functionality
- **Inheritance & Interfaces**: Understanding class hierarchies and modular behavior
- **Functions**: Writing and calling reusable methods
- **Classes & Objects**: Creating objects and calling methods with dot notation
- **Commenting Code**: Writing meaningful comments for clarity

If you're familiar with these concepts, you're good to go! If not, don't worry—these can be picked up quickly. 🚀

---

## 🏗️ Design Patterns Included
This repository covers **three categories** of design patterns:

### ✅ **Creational Patterns** (How objects are created)
These patterns deal with **object creation mechanisms**, making the process more flexible and reusable.

- `Singleton` → Ensures only **one instance** of a class exists and provides a global access point.
- `Factory` → Creates objects without specifying their **exact class**.
- `Builder` → Constructs **complex objects step-by-step** while keeping the code readable.
- `Prototype` → Creates new objects by **cloning** an existing object.

---

### ✅ **Structural Patterns** (How objects are composed)
These patterns focus on **how objects are structured** and how they work together efficiently.

- `Adapter` → Allows incompatible interfaces to **work together** by acting as a bridge.
- `Composite` → Treats **individual objects and groups of objects** uniformly.
- `Decorator` → Dynamically **adds new behavior** to objects without modifying their code.
- `Proxy` → Controls access to an object, adding an **extra layer** of functionality.

---

### ✅ **Behavioral Patterns** (How objects interact)
These patterns define **how objects communicate** and distribute responsibilities.

- `Template Method` → Defines the **skeleton of an algorithm**, letting subclasses fill in specific steps.
- `Strategy` → Allows swapping between **different algorithms** at runtime.
- `Observer` → Notifies dependent objects **when a state changes** (like event listeners).
- `Iterator` → Provides a way to **traverse elements** in a collection without exposing the structure.
- `Command` → Encapsulates a **request as an object**, allowing for undoable operations.
- `Interpreter` → Evaluates and processes **custom language or expression trees**.

---

Each pattern includes **examples, explanations, and use cases** to help you understand its role and implementation.

---

## 💡 Why Learn Design Patterns?
Understanding design patterns helps you:
- Write **cleaner, more maintainable code**
- Improve **code reusability** and **scalability**
- Follow **best practices** in software design
- Become a better software developer overall!

---

### 🌟 Ready to Dive In?
Check out the individual pattern implementations and **start coding!** If you have any questions or suggestions, feel free to contribute or reach out.

Happy coding! 🎉
